// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import {
  useAppAccessRules,
  useAppAuthConfig,
  useDirectory,
  useDirectoryGroups,
  useDirectoryUsers,
  useTeamDirectories,
} from "@/wab/client/components/app-auth/app-auth-contexts";
import DirectoryUserRow from "@/wab/client/components/app-auth/DirectoryUserRow";
import GroupItem from "@/wab/client/components/app-auth/GroupItem";
import InlineEditableResource from "@/wab/client/components/app-auth/InlineEditableResource";
import ContextMenu from "@/wab/client/components/ContextMenu";
import ListItem from "@/wab/client/components/ListItem";
import { confirm } from "@/wab/client/components/quick-modals";
import Button from "@/wab/client/components/widgets/Button";
import Textbox from "@/wab/client/components/widgets/Textbox";
import { useAppCtx } from "@/wab/client/contexts/AppContexts";
import {
  DefaultDirectoryConfigProps,
  PlasmicDirectoryConfig,
} from "@/wab/client/plasmic/plasmic_kit_end_user_management/PlasmicDirectoryConfig";
import { mkUuid, uniqueName } from "@/wab/shared/common";
import {
  ApiEndUser,
  ApiEndUserDirectory,
  ApiProject,
} from "@/wab/shared/ApiSchema";
import { HTMLElementRefOf } from "@plasmicapp/react-web";
import { Menu, notification } from "antd";
import * as React from "react";
import { FocusScope } from "react-aria";
import { Modal } from "@/wab/client/components/widgets/Modal";
import { KeyedMutator } from "swr";
import validator from "validator";

// Your component props start with props for variants and slots you defined
// in Plasmic, but you can add more here, like event handlers that you can
// attach to named nodes in your component.
//
// If you don't want to expose certain variants or slots as a prop, you can use
// Omit to hide them:
//
// interface DirectoryConfigProps extends Omit<DefaultDirectoryConfigProps, "hideProps1"|"hideProp2"> {
//   // etc.
// }
//
// You can also stop extending from DefaultDirectoryConfigProps altogether and have
// total control over the props for your component.
export interface DirectoryConfigProps extends DefaultDirectoryConfigProps {
  goBack: () => void;
  onCancel: () => void;
  project: ApiProject;
  directoryId: string;
}

function DirectoryConfig_(
  props: DirectoryConfigProps,
  ref: HTMLElementRefOf<"div">
) {
  const appCtx = useAppCtx();
  const { goBack, onCancel, directoryId, project, ...rest } = props;

  const appId = project.id;
  const { mutate: mutateAppAuthConfig } = useAppAuthConfig(appCtx, appId);
  const { accesses } = useAppAccessRules(appCtx, appId);
  const { groups, mutate: mutateGroups } = useDirectoryGroups(
    appCtx,
    directoryId
  );
  const { directory, mutate: mutateDirectory } = useDirectory(
    appCtx,
    directoryId
  );
  const { directories, mutate: mutateDirectories } = useTeamDirectories(
    appCtx,
    project.teamId ?? undefined
  );
  const { users, mutate: mutateUsers } = useDirectoryUsers(appCtx, directoryId);
  const [showAddUser, setShowAddUser] = React.useState(false);
  const [menuPosition, setMenuPosition] = React.useState<
    { x: number; y: number } | undefined
  >(undefined);

  async function changeUserGroups(user: ApiEndUser, newGroupsIds: string[]) {
    await mutateUsers(
      async () => {
        await appCtx.api.updateEndUserGroups(
          directoryId,
          user.id,
          newGroupsIds
        );
        return await appCtx.api.listDirectoryUsers(directoryId);
      },
      {
        optimisticData: users.map((_user) => {
          if (_user.id === user.id) {
            return {
              ...user,
              groups: newGroupsIds.map((groupId) => {
                return groups.find((g) => g.id === groupId)!;
              }),
            };
          }
          return _user;
        }),
      }
    );
  }

  return (
    <>
      <PlasmicDirectoryConfig
        directoryName={
          <InlineEditableResource
            visibleValue={<span>{directory?.name}</span>}
            value={directory?.name ?? ""}
            onChange={async (name) => {
              await mutateDirectory(
                async () => {
                  const result = await appCtx.api.updateEndUserDirectory(
                    directoryId,
                    {
                      name,
                    }
                  );
                  return result;
                },
                {
                  optimisticData: {
                    ...directory!,
                    name,
                  },
                }
              );
            }}
          />
        }
        backBtn={{
          onClick: () => {
            goBack();
          },
        }}
        gearIcon={{
          onClick: (e) => {
            setMenuPosition({
              x: e.clientX,
              y: e.clientY,
            });
          },
        }}
        closeIcon={{
          onClick: onCancel,
        }}
        addGroupBtn={{
          onClick: async () => {
            const groupName = uniqueName(
              groups.map((g) => g.name),
              "My new group"
            );

            await mutateGroups(
              async () => {
                await appCtx.api.createDirectoryGroup(directoryId, groupName);
                return await appCtx.api.listDirectoryGroups(directoryId);
              },
              {
                optimisticData: [
                  ...groups,
                  {
                    // Make every fake group id unique to avoid multiple create issues
                    id: mkUuid(),
                    name: groupName,
                    isFake: true,
                  },
                ],
              }
            );
          },
        }}
        groupsList={{
          children:
            groups.length > 0 ? (
              groups
                .sort((a, b) => {
                  if (a.name < b.name) {
                    return -1;
                  }
                  if (a.name > b.name) {
                    return 1;
                  }
                  return 0;
                })
                .map((group, idx) => {
                  return (
                    <GroupItem
                      key={group.id}
                      groupName={group.name}
                      withoutBorder={idx === groups.length - 1}
                      isFake={group.isFake}
                      onRemove={async () => {
                        const isUsingGroupAccess = accesses.some(
                          (a) =>
                            "directoryEndUserGroupId" in a &&
                            a.directoryEndUserGroupId === group.id
                        );

                        if (isUsingGroupAccess) {
                          notification.error({
                            message:
                              "Cannot delete group while it is being used in access list",
                          });
                          return;
                        }

                        const confirmed = await confirm({
                          title: "Delete group",
                          message: `Are you sure you want to delete group "${group.name}"?`,
                        });

                        if (confirmed) {
                          await mutateGroups(
                            async () => {
                              await appCtx.api.deleteDirectoryGroup(
                                directoryId,
                                group.id
                              );
                              return await appCtx.api.listDirectoryGroups(
                                directoryId
                              );
                            },
                            {
                              optimisticData: groups.filter(
                                (g) => g.id !== group.id
                              ),
                            }
                          );

                          await mutateUsers(
                            async () => {
                              return await appCtx.api.listDirectoryUsers(
                                directoryId
                              );
                            },
                            {
                              optimisticData: users.map((user) => {
                                return {
                                  ...user,
                                  groups: user.groups.filter(
                                    (g) => g.id !== group.id
                                  ),
                                };
                              }),
                            }
                          );
                        }
                      }}
                      onRename={async (name) => {
                        await mutateGroups(
                          async () => {
                            await appCtx.api.updateDirectoryGroup(
                              directoryId,
                              group.id,
                              name
                            );
                            return await appCtx.api.listDirectoryGroups(
                              directoryId
                            );
                          },
                          {
                            optimisticData: groups.map((g) => {
                              if (g.id === group.id) {
                                return {
                                  ...g,
                                  name,
                                };
                              }
                              return g;
                            }),
                          }
                        );
                        await mutateUsers(
                          async () => {
                            return await appCtx.api.listDirectoryUsers(
                              directoryId
                            );
                          },
                          {
                            optimisticData: users.map((user) => {
                              return {
                                ...user,
                                groups: user.groups.map((g) => {
                                  if (g.id === group.id) {
                                    return {
                                      ...g,
                                      name,
                                    };
                                  }
                                  return g;
                                }),
                              };
                            }),
                          }
                        );
                      }}
                    />
                  );
                })
            ) : (
              <ListItem hideIcon>You have no groups yet</ListItem>
            ),
        }}
        directoryUsers={{
          children: users.map((user) => {
            return (
              <DirectoryUserRow
                key={user.id}
                user={user}
                groups={groups}
                changeUserGroups={changeUserGroups}
                onDelete={async () => {
                  await mutateUsers(
                    async () => {
                      await appCtx.api.removeEndUserFromDirectory(
                        directoryId,
                        user.id
                      );
                      return await appCtx.api.listDirectoryUsers(directoryId);
                    },
                    {
                      optimisticData: users.filter((u) => u.id !== user.id),
                    }
                  );
                }}
              />
            );
          }),
        }}
        addUserBtn={{
          onClick: () => {
            setShowAddUser(true);
          },
        }}
        root={{ ref }}
        {...rest}
      />
      {showAddUser && directory && (
        <AddUserToDirectoryModal
          directory={directory}
          users={users}
          mutateUsers={mutateUsers}
          onCancel={() => setShowAddUser(false)}
        />
      )}
      {menuPosition && (
        <ContextMenu
          pageX={menuPosition.x}
          pageY={menuPosition.y}
          onHide={() => setMenuPosition(undefined)}
          overlay={
            <Menu>
              <Menu.Item
                onClick={async () => {
                  const isUsingGroupAccess = accesses.some(
                    (a) => "directoryEndUserGroupId" in a
                  );

                  if (isUsingGroupAccess) {
                    notification.error({
                      message:
                        "Cannot delete directory while group is being used in access list",
                    });
                    return;
                  }

                  if (directories.length === 1) {
                    notification.error({
                      message: "Cannot delete last directory",
                    });
                    return;
                  }

                  const directoryUsage =
                    await appCtx.api.getEndUserDirectoryApps(directoryId);

                  const usedInOtherApps = directoryUsage.filter(
                    (d) => d.id !== appId
                  );

                  if (usedInOtherApps.length > 0) {
                    notification.error({
                      message: `Cannot delete directory, currently being used in other apps: ${usedInOtherApps
                        .map((d) => d.name)
                        .join(", ")}`,
                    });
                    return;
                  }

                  const substituteDirectory = directories.find(
                    (d) => d.id !== directoryId
                  );

                  const confirmed = await confirm({
                    title: "Delete directory",
                    message: `Are you sure you want to delete "${directory?.name}"? The app auth will be pointing to "${substituteDirectory?.name}".`,
                  });

                  if (confirmed) {
                    await mutateAppAuthConfig(async () => {
                      return appCtx.api.upsertAppAuthConfig(appId, {
                        directoryId: substituteDirectory!.id,
                      });
                    });

                    await mutateDirectories(
                      async () => {
                        await appCtx.api.deleteEndUserDirectory(directoryId);
                        return appCtx.api.listTeamDirectories(project.teamId!);
                      },
                      {
                        optimisticData: directories.filter(
                          (d) => d.id !== directoryId
                        ),
                      }
                    );

                    goBack();
                  }
                }}
              >
                Delete directory
              </Menu.Item>
            </Menu>
          }
        />
      )}
    </>
  );
}

function AddUserToDirectoryModal(props: {
  directory: ApiEndUserDirectory;
  users: ApiEndUser[];
  mutateUsers: KeyedMutator<ApiEndUser[]>;
  onCancel: () => void;
}) {
  const appCtx = useAppCtx();
  const { directory, users, mutateUsers, onCancel } = props;
  const [userEmail, setUserEmail] = React.useState("");

  async function addUserToDirectory() {
    if (!validator.isEmail(userEmail)) {
      notification.warn({
        message: "Invalid email",
      });
      return;
    }

    if (users.some((u) => u.email === userEmail)) {
      notification.warn({
        message: "User already in the directory",
      });
      return;
    }

    await appCtx.api.addDirectoryEndUsers(directory.id, [userEmail]);
    await mutateUsers();
    setUserEmail("");
    notification.success({
      message: "User added",
    });
  }

  return (
    <Modal
      title={`Add user to "${directory.name}"`}
      open
      onCancel={onCancel}
      destroyOnClose
      footer={null}
    >
      <FocusScope contain>
        <div>
          <Textbox
            placeholder="Enter user email"
            autoFocus
            value={userEmail}
            onChange={(e) => {
              setUserEmail(e.target.value);
            }}
            onEnter={async () => {
              await addUserToDirectory();
            }}
          />
          <div className="mt-xlg">
            <Button
              className="mr-sm"
              type="primary"
              onClick={async () => {
                await addUserToDirectory();
              }}
            >
              Add user
            </Button>
            <Button
              onClick={() => {
                onCancel();
              }}
            >
              Cancel
            </Button>
          </div>
        </div>
      </FocusScope>
    </Modal>
  );
}

const DirectoryConfig = React.forwardRef(DirectoryConfig_);
export default DirectoryConfig;
