// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import { useCommentsCtx } from "@/wab/client/components/comments/CommentsProvider";
import { getSetOfVariantsForViewCtx } from "@/wab/client/components/comments/utils";
import { useUserMentions } from "@/wab/client/components/user-mentions/useUserMentions";
import { useAppCtx } from "@/wab/client/contexts/AppContexts";
import { useViewCtxMaybe } from "@/wab/client/contexts/StudioContexts";
import {
  DefaultCommentPostFormProps,
  PlasmicCommentPostForm,
} from "@/wab/client/plasmic/plasmic_kit_comments/PlasmicCommentPostForm";
import {
  ApiComment,
  CommentThreadId,
  RootCommentData,
  ThreadCommentData,
} from "@/wab/shared/ApiSchema";
import { ensure, spawn, withoutNils } from "@/wab/shared/common";
import { observer } from "mobx-react";
import * as React from "react";
import { useState } from "react";

export type CommentPostFormProps = DefaultCommentPostFormProps & {
  threadId?: CommentThreadId;
  editComment?: ApiComment;
  setIsEditing?: (val: boolean) => void;
};

const CommentPostForm = observer(function CommentPostForm(
  props: CommentPostFormProps
) {
  const { threadId, isEditing, setIsEditing, editComment, ...rest } = props;
  const [value, setValue] = useState(editComment?.body || "");

  const viewCtx = useViewCtxMaybe();
  const focusedTpls = withoutNils(viewCtx?.focusedTpls() ?? []);
  const selectedNewThreadTpl = viewCtx?.getSelectedNewThreadTpl();

  const { projectId, branchId, bundler } = useCommentsCtx();

  const api = useAppCtx().api;

  const formRef = React.useRef<HTMLFormElement>(null);
  const popoverTargetRef = React.useRef<HTMLDivElement>(null);

  const { onKeyHandler, onChangeHandler, userMentionsPopover } =
    useUserMentions({
      popoverTargetRef,
      popoverOffset: isEditing ? 0 : -50,
      value,
      onValueChange: setValue,
    });

  if (!viewCtx || (focusedTpls.length !== 1 && !selectedNewThreadTpl)) {
    return null;
  }

  const focusedTpl = selectedNewThreadTpl || focusedTpls[0];

  function isValidComment() {
    return (
      value.trim().length > 0 || value.trim() !== editComment?.body?.trim()
    );
  }

  return (
    <>
      <form
        ref={formRef}
        onSubmit={async (e) => {
          e.preventDefault();

          if (isEditing && editComment) {
            if (value.trim() !== editComment.body.trim()) {
              spawn(
                api.editComment(projectId, branchId, editComment.id, {
                  body: value.trim(),
                })
              );
            }
            setIsEditing?.(false);
            return;
          }

          setValue("");
          if (threadId) {
            const commentData: ThreadCommentData = { body: value };
            await api.postThreadComment(
              projectId,
              branchId,
              threadId,
              commentData
            );
          } else {
            const location = {
              subject: bundler.addrOf(ensure(focusedTpl, "")),
              variants: getSetOfVariantsForViewCtx(viewCtx, bundler).map((pv) =>
                bundler.addrOf(pv)
              ),
            };
            const commentData: RootCommentData = { body: value, location };
            await api.postRootComment(projectId, branchId, commentData);
          }
          viewCtx.setSelectedNewThreadTpl(null);
        }}
      >
        <PlasmicCommentPostForm
          {...rest}
          root={{
            ref: popoverTargetRef,
          }}
          isEditing={isEditing}
          bodyInput={{
            autoComplete: "off",
            placeholder: "Add a comment",
            textAreaInput: {
              value,
            },
            onChange: (val) => {
              if (val === undefined) {
                // Plexus Input triggers onChange with undefined on first render even if we pass a controlled value
                onChangeHandler(isEditing ? editComment?.body || "" : "");
              } else {
                onChangeHandler(val);
              }
            },
            onKeyDown: onKeyHandler,
            onBlur: () => {
              if (isEditing) {
                formRef.current?.requestSubmit();
                setIsEditing?.(false);
              }
            },
          }}
          submitButton={{
            htmlType: "submit",
            disabled: !isValidComment(),
          }}
        />
      </form>

      {userMentionsPopover}
    </>
  );
});

export default CommentPostForm;
